"""Script to create an index file from my Zettelkasten notes (md files)"""
from collections import defaultdict
from pathlib import Path
import re
from typing import NamedTuple

INDEX_NAME = "index.md"
SUPER_INDEX_NAME = "super_index.md"
NOTES_DIR = Path("notes")
TAG_REGEX = re.compile(r"#\S+")
HEADER = """# Christopher's Notes Archive

Idea from [this post](https://www.edwinwenink.xyz/posts/42-vim_notetaking/).
This file gets generated by [this script](index.py).
[Structured notes](super_index.md) is a subset of this index.

## Categories

"""

SUPER_HEADER = """# Christopher's Structure Notes Archive

Idea from
[this post](https://zettelkasten.de/posts/three-layers-structure-zettelkasten/).
This file gets generated by [this script](index.py).

Go to the [main index](index.md) for a full list of all the notes.
This index only include structured notes that are a subset of the
[main index](index.md).

## Categories

"""


class Note(NamedTuple):
    title: str
    filename: str
    tag_type: str


def group_notes_by_tag(
    directory: Path = Path.cwd() / NOTES_DIR,
) -> defaultdict[str, list[Note]]:
    notes_grouped_by_tags = defaultdict(list)

    filenames = directory.glob("*.md")

    for filename in filenames:
        note_content = filename.read_text()
        title = note_content.splitlines()[0].strip("# ").capitalize()
        tag_lines = "\n".join(
            line for line in note_content.splitlines() if line.startswith("#")
        )
        tags = re.findall(TAG_REGEX, tag_lines)

        for tag in tags:
            if tag in ["#", "##", "###", "####", "#####"]:
                tag_type = "invalid"
            elif tag.startswith("##"):
                tag_type = "super"
            else:
                tag_type = "regular"

            if tag_type != "invalid":
                tag = tag.lstrip("#").title()
                notes_grouped_by_tags[tag].append(
                    Note(title=title, filename=filename.name, tag_type=tag_type)
                )

    return notes_grouped_by_tags


def create_index(tag_index_tree: defaultdict[str, list[Note]]) -> None:
    output = [HEADER]
    super_output = [SUPER_HEADER]

    table_of_contents = list()
    super_table_of_contents = list()

    contents = list()
    super_contents = list()

    for tag, notes in sorted(tag_index_tree.items()):
        tag_type = ""
        contents_tag = tag.lower().replace("_", "-")
        tag = tag.lower().replace("_", " ").title()
        for note in notes:
            if note.tag_type == "regular":
                tag_type = "regular"
            else:
                tag_type = "super"

        if tag_type == "regular":
            contents.append(f"## {tag}\n\n")
            table_of_contents.append(f"* [{tag}](#{contents_tag})\n")
        else:
            super_contents.append(f"## {tag}\n\n")
            super_table_of_contents.append(f"* [{tag}](#{contents_tag})\n")

        for note in sorted(notes):
            note_filepath = NOTES_DIR / note.filename
            if note.tag_type == "regular":
                contents.append(f"* [{note.title}]({note_filepath})\n")

            else:
                super_contents.append(f"* [{note.title}]({note_filepath})\n")

        if tag_type == "regular":
            contents.append("\n* [Return to the top](#categories)\n\n")
        else:
            super_contents.append("* [Return to the top](#categories)\n\n")

    output += table_of_contents
    output += contents

    super_output += super_table_of_contents
    super_output += super_contents

    with open(INDEX_NAME, "w") as f:
        f.write("".join(output))

    with open(SUPER_INDEX_NAME, "w") as f:
        f.write("".join(super_output))


if __name__ == "__main__":
    tag_index_tree = group_notes_by_tag()
    create_index(tag_index_tree)
